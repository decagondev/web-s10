<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Objective 1 - Understanding Immutability</title>
<meta name="identifier" content="g5c50d3b24fc1c430e06aa09433b46c80"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
</head>
<body>
<div class=" border border-trbl" style="background-color: #00808c; color: #ffffff; padding: 2px 10px; border: 1px solid black;">
    <h3><strong>Overview</strong></h3>
</div>
<div class="content-box pad-box-mini border border-rbl">
    <p>Mutable objects are objects whose state is allowed to change over time. An immutable value is an exact opposite; after it has been created, it can never change. There are some real benefits from making your state immutable. We won't go over all the benefits here, but we will talk about predictability and avoiding mutation.</p>
    <p>Mutation hides change, which can create unexpected side effects. This can lead to some nasty bugs in our code. When we enforce immutability, we can keep our application architecture and mental model simple, making it easier to reason about the application. Simply put, it is very easy to predict how the state object will change based on certain actions/events. Without immutability, our state object can be changed or updated in unpredictable ways, causing weird behavior or bugs.</p>
</div>
<div class="border border-trbl" style="background-color: #00808c; color: #ffffff; padding: 2px 10px; border: 1px solid black;">
    <h3><strong>How to Build It</strong></h3>
</div>
<div class="content-box pad-box-mini border border-rbl">
    <p>You should know that numbers and strings are <em>immutable</em> types of data. A number cannot magically turn into a different number. If the number is held inside a variable declared with <code>let</code>, then this variable can be reassigned to a different number, creating the illusion that the number itself is changing. The same goes for strings: strings are immutable: once declared, a string never changes. Methods like <code>toUpperCase</code> just return a brand new string.</p>
    <p>Objects are different. These are <em>mutable</em> data structures! By default, in JavaScript we can add, overwrite and delete the properties of any object. The object itself is the <em>same</em> object, but its <em>shape</em> suffers mutations if we perform those kinds of operations. This is part of what makes JavaScript so flexible and dynamic, but it can also be a source of bugs in certain scenarios, when an object unexpectedly changes shape.</p>
    <p>In functional programming, and when working with React and Redux, we try to avoid mutating objects. The spread operator comes in handy for creating copies of objects to avoid mutating in place the original ones:</p>
    <pre style="background: none 0% 0% / auto repeat scroll padding-box border-box #ffffff; border: 1px solid #c7cdd1; clear: none; color: #24292e; cursor: auto; direction: ltr; font: 12px / 14.4px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px 0px 12px; padding: 9px; text-align: start; text-decoration: none solid #24292e; text-indent: 0px; white-space: pre-wrap; border-collapse: separate; border-spacing: 0px;" data-hljs-language="javascript"><code style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0); border: 0px none #24292e; font: 16px / 19.2px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px; padding: 0px;"><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> obj = { <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">name</span>: <span style="border: 0px none #032f62; color: #032f62; text-decoration: none solid #032f62;">'Pam'</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">age</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">34</span> }<br><span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// obj.age = 35 // CAREFUL! This would mutate the original object in place</span><br><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> obj2 = { ...obj, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">age</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">35</span> } <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Copy with a modification, preserving the original</span></code></pre>
    <p>This preserves the original object. It must be noted that a copy built like this is a <em>shallow</em> copy. The spread operator won't recursively copy mutable structures nested inside the object. If a property of an original object contains another object, creating a shallow copy means that the nested object is one and the same for both original and copy. Suppose we wish to increase the age of a user nested inside an object, without mutating the object:</p>
    <pre style="background: none 0% 0% / auto repeat scroll padding-box border-box #ffffff; border: 1px solid #c7cdd1; clear: none; color: #24292e; cursor: auto; direction: ltr; font: 12px / 14.4px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px 0px 12px; padding: 9px; text-align: start; text-decoration: none solid #24292e; text-indent: 0px; white-space: pre-wrap; border-collapse: separate; border-spacing: 0px;" data-hljs-language="javascript"><code style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0); border: 0px none #24292e; font: 16px / 19.2px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px; padding: 0px;"><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> data = { <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">id</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">7</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">user</span>: { <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">name</span>: <span style="border: 0px none #032f62; color: #032f62; text-decoration: none solid #032f62;">'John'</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">age</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">45</span> } } <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// How can we increase the age?</span><br><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> newData = { ...data } <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Shallow copy</span><br>newData.<span>user</span>.<span>age</span> = <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">46</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Mutating data, falsely believing the original data.user is safe</span><br>newData.<span>user</span>.<span>age</span> <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Evaluates to 46 like we wanted...</span><br>data.<span>user</span>.<span>age</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Oh, no! This also evaluates to 46. We mutated the original!</span></code></pre>
    <p>Luckily it's easy to modify our technique to avoid mutating the original user:</p>
    <pre style="background: none 0% 0% / auto repeat scroll padding-box border-box #ffffff; border: 1px solid #c7cdd1; clear: none; color: #24292e; cursor: auto; direction: ltr; font: 12px / 14.4px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px 0px 12px; padding: 9px; text-align: start; text-decoration: none solid #24292e; text-indent: 0px; white-space: pre-wrap; border-collapse: separate; border-spacing: 0px;" data-hljs-language="javascript"><code style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0); border: 0px none #24292e; font: 16px / 19.2px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px; padding: 0px;"><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> data = { <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">id</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">7</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">user</span>: { <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">name</span>: <span style="border: 0px none #032f62; color: #032f62; text-decoration: none solid #032f62;">'John'</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">age</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">45</span> } }<br><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> newData = { ...data, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">user</span>: { ...data.<span>user</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">age</span>: <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">46</span> } } <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// A birthday without mutations</span></code></pre>
    <p>Arrays in JavaScript are also mutable data structures. Many array methods, like <code>push</code>, <code>pop</code> or <code>splice</code> are destructive, in the sense that they mutate the array on which the method is called. Other methods are non-destructive and return a new array without damaging the original one, like <code>filter</code>, <code>map</code> and <code>concat</code>. The spread operator also comes in handy, if we wish to add elements to an array without causing any mutations:</p>
    <pre style="background: none 0% 0% / auto repeat scroll padding-box border-box #ffffff; border: 1px solid #c7cdd1; clear: none; color: #24292e; cursor: auto; direction: ltr; font: 12px / 14.4px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px 0px 12px; padding: 9px; text-align: start; text-decoration: none solid #24292e; text-indent: 0px; white-space: pre-wrap; border-collapse: separate; border-spacing: 0px;" data-hljs-language="javascript"><code style="background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0); border: 0px none #24292e; font: 16px / 19.2px Monaco, Menlo, Consolas, 'Courier New', monospace; margin: 0px; padding: 0px;"><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> arr1 = [<span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">1</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">2</span>, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">3</span>]<br><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> arr2 = arr1.<span style="border: 0px none #6f42c1; color: #6f42c1; text-decoration: none solid #6f42c1;">concat</span>(<span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">4</span>)<br><span style="border: 0px none #d73a49; color: #d73a49; text-decoration: none solid #d73a49;">const</span> arr3 = [...arr2, <span style="border: 0px none #005cc5; color: #005cc5; text-decoration: none solid #005cc5;">5</span>]<br><br>arr1 <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Evaluates to [1, 2, 3]</span><br>arr2 <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Evaluates to [1, 2, 3, 4]</span><br>arr3 <span style="border: 0px none #6a737d; color: #6a737d; text-decoration: none solid #6a737d;">// Evaluates to [1, 2, 3, 4, 5]</span></code></pre>
    <p>In conclusion, whenever you are working with an array or an object, ask yourself whether the operation you're performing is destructive or non-destructive! Depending on the situation, you might wish to avoid causing mutations.</p>
</div>
<div class="border border-trbl" style="background-color: #00808c; color: #ffffff; padding: 2px 10px; border: 1px solid black;">
    <h3><strong>Video Walkthrough</strong></h3>
</div>
<div class="content-box pad-box-mini border border-rbl">
    <p><iframe class="wistia_embed" title="understanding immutability" src="https://fast.wistia.net/embed/iframe/vovg3l6a47?seo=false&amp;videoFoam=false" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></p>
</div>
</body>
</html>